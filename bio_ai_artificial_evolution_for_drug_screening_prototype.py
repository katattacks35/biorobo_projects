# -*- coding: utf-8 -*-
"""bio_ai_rnd_prototype

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oQ83jwAZdIwcQzO410MABnViGvxb617T
"""

import numpy as np

target = "CCCCCCNCOH"

drugs = ["O=C(c1ccc(F)c(F)c1Nc1ccc(I)cc1F)N1CC(O)([C@@H]2CCCCN2)C1","COc1c(OCCCN2CCOCC2)ccc2c1N=C(NC(=O)c1cnc(N)nc1)N1CCN=C21",
         "CS(=O)(=O)c1ccc(C(=O)Nc2ccc(Cl)c(-c3ccccn3)c2)c(Cl)c1ccc","C[C@@H](Oc1cc(-c2cnn(C3CCNCC3)c2)cnc1N)c1c(Cl)ccc(F)c1Cl",
         "CCCCCCCCCC(C)C1OCc2c(C[N+](C)(C)CCCNC(=O)CCCCC)cnc(C)c2O","CCCCCCCCCC(C)C1OCc2c(C[N+](C)(C)CCCNC(=O)CCCCC)cnc(C)c2O",
         "FC(F)(F)c1cccc([C+](c2c[nH]c3ccccc23)c2c[nH]c3ccccc23)c1","C=CCc1cccc(Oc2ccc(C(=O)CC)cc2)c1OCCC[N+](C)(C)CC(=O)NCCC",
         "CCCCCCCCCCCCCCOc1cccc(CN(C(C)=O)c2cccc(C[n+]3csc(C)c3)c2","COc1ccc(CC(=O)NC(=N)N[C@H](CO)C(=O)Nc2cc(S(N)(=O)=O)ccc2",
         "N=C(N)c1ccc(C2=NOC(CC(=O)N[C@H](CC(=O)O)Cc3ccccc3)C2)cc1"]

def test_toxicity(drug):
  """Returns numerical predicition of toxcity based on functional groups present"""
  toxic_groups = ["(F)","cnc","C(Cl)"]
  score = 0
  for group in toxic_groups:
    if drug.count(group) > 0:
        score += 1
    if drug.count(group) > 1:
        score += 2

  return score

def test_binding(target,drug):
  """Returns the fitness value of drug binding to target"""
  binding_sites = [["C(=O)","OH"],["CCC","NC"],["ccc","CNC"]]
  binding_sites_target = []

  for n in range(len(binding_sites)):
    if target.count(binding_sites[n][0]) > 0:
      binding_sites_target.append(binding_sites[n][1])
    if target.count(binding_sites[n][1]) > 0:
      binding_sites_target += binding_sites[n][0]

  score = 0
  for site in binding_sites_target:
    if drug.count(site) > 0:
      score += 1
    if drug.count(site) > 1:
      score += 2

  return score

def get_fitness(candidate):
  score = test_binding(target,candidate) - test_toxicity(candidate)
  fitness = (score**2) + 1

  return fitness

def get_population_fitness(population):
 """Returns fitness values of drug population"""

 fitnesses = []

 for i in range(len(population)):
   score = test_binding(target,population[i]) - test_toxicity(population[i])
   fitness = (score**2) + 1
   fitnesses.append(fitness)

 fitness_scores = np.array(fitnesses)
 return fitness_scores

print(get_population_fitness(drugs))


population = np.array(["O=C(c1ccc(F)c(F)c1Nc1ccc(I)cc1F)N1CC(O)([C@@H]2CCCCN2)C1","COc1c(OCCCN2CCOCC2)ccc2c1N=C(NC(=O)c1cnc(N)nc1)N1CCN=C21",
         "CS(=O)(=O)c1ccc(C(=O)Nc2ccc(Cl)c(-c3ccccn3)c2)c(Cl)c1ccc","C[C@@H](Oc1cc(-c2cnn(C3CCNCC3)c2)cnc1N)c1c(Cl)ccc(F)c1Cl",
         "CCCCCCCCCC(C)C1OCc2c(C[N+](C)(C)CCCNC(=O)CCCCC)cnc(C)c2O","CCCCCCCCCC(C)C1OCc2c(C[N+](C)(C)CCCNC(=O)CCCCC)cnc(C)c2O",
         "FC(F)(F)c1cccc([C+](c2c[nH]c3ccccc23)c2c[nH]c3ccccc23)c1","C=CCc1cccc(Oc2ccc(C(=O)CC)cc2)c1OCCC[N+](C)(C)CC(=O)NCCC",
         "CCCCCCCCCCCCCCOc1cccc(CN(C(C)=O)c2cccc(C[n+]3csc(C)c3)c2","COc1ccc(CC(=O)NC(=N)N[C@H](CO)C(=O)Nc2cc(S(N)(=O)=O)ccc2",
         "N=C(N)c1ccc(C2=NOC(CC(=O)N[C@H](CC(=O)O)Cc3ccccc3)C2)cc1"])

#Tournament Selection code
def tournament_selection(old_population,fitnesses,t_size = 2):
    """Performs tournament based selection on a population, returns the new population """

    if np.isnan(fitnesses).any():
      print("ERROR - Some fitnesses are NaN. Returning original population")
      return old_population
    new_population = []
    pop_size = old_population.size
    if t_size > pop_size:
        print("Tournament size too big, larger than population size")
        t_size = pop_size
    for i in range(pop_size):
        #pick contentenders for tournament
        contender_indexs = np.random.choice(range(pop_size), replace = False, size=t_size)
        #pick winner aka one with largest fitness of the contenders
        winner_index = contender_indexs[np.argmax(fitnesses[contender_indexs])]

        new_population.append(old_population[winner_index])
    return np.array(new_population)


#Rank-based selection code
def get_rank_select_prob(population,fitnesses):
    """ Returns the selection probabilities for individuals in a population according to rank based selection
    Parameters:
      population - the population to calculate selection probabilities
      fitnesses - array of fitnesses assocoiated with the individuals in old_population

    Returns
      The selection probabilities for each individual
    """

    if np.isnan(fitnesses).any():#If the fitness values aren't valid return an array filled with NaNs for the probabilities
      prob_of_selection = np.full(fitnesses.shape,fill_value = np.nan)
      return prob_of_selection

    order = np.array(-fitnesses).argsort() #returns indexes which would sort the array highest to lowest
    ranks = (order.argsort() +1).astype('float')#sorting the indexes lowest to highest gives us the rank, add one to account for first index being zero

    prob_of_selection = (population.size - ranks + 1.0)/np.sum(ranks)
    return prob_of_selection

def rank_based_selection(old_population,fitnesses):
    """Performs rank based selection on a population, returns the new population   """

    if np.isnan(fitnesses).any():
      print("ERROR - Some fitnesses are NaN. Cannot calculate selection probabilities returning original population")
      return old_population

    prob_of_selection = get_rank_select_prob(old_population,fitnesses)
    new_population = np.random.choice(old_population, size = len(old_population),p = prob_of_selection)

    return new_population


#proportionate selection code
def get_proportionate_select_prob(population,fitnesses):
    """ Returns the selection probabilities for individuals in a population according to proportianate selection
    Parameters:
      population - the population to calculate selection probabilities
      fitnesses - array of fitnesses assocoiated with the individuals in old_population

    Returns
      The selection probabilities for each individual
    """

    total_fitness = np.sum(fitnesses)
    prob_of_selection = fitnesses/total_fitness
    return prob_of_selection

def proportionate_selection(old_population,fitnesses):
    """Performs proportional based selection on a population, returns the new population
    Parameters:
        old_population - the population to perform selection on
        fitnesses - array of fitnesses assocoiated with the individuals in old_population

    Returns:
        The new population
    """
    if np.isnan(fitnesses).any():
      print("ERROR - Some fitnesses are NaN. Cannot calculate selection probabilities returning original population")
      return old_population

    prob_of_selection = get_proportionate_select_prob(old_population,fitnesses)
    new_population = np.random.choice(old_population, size = len(old_population),p = prob_of_selection)
    return new_population

#Demostrates selection
print("Original population: {}".format(population))

new_population = proportionate_selection(population,get_population_fitness(population))


print("Population after proportionate selection {}".format(new_population))

def perform_selection(old_population,fitnesses,selection_method,selection_params=None):
    """Applies a selection operator on a population, returns the new population
    Parameters:
        old_population - the population to perform selection on
        selection_method - The selection operator to be applied, valid values are:
                           "proportionate","rank" or "tournament"
        selection_params - Dictionary of parameters for selection operators
    Returns:
        The new population
    """
    if selection_method == "proportionate":
        new_population = proportionate_selection(old_population,fitnesses)
    elif selection_method == "rank":
        new_population = rank_based_selection(old_population,fitnesses)
    elif selection_method == "tournament":
        new_population = tournament_selection(old_population,fitnesses,selection_params["tournament_size"])
    else:
        print("\"{}\" is not recognised as a selection method. Returning original population".format(selection_method))
        new_population = old_population
    return new_population

def one_point_crossover(individual1,individual2,crossover_point = -1):
  """Applies one point crossover to two individual genomes
  Parameters:
    individual1 - Genome1
    individual2 - Genome2
    crossover_point (optional, default = -1) - The crossover point in the genome string ie. the position in the string before which the crossover is applied.
                                               If set to -1 a random crossover point will be used.
  Returns:
     The two individuals
  """
  if (len(individual1)!=len(individual2) or len(individual1) == 0 or len(individual2) == 0):
    print("Individual genome sizes must be equal and larger than zero")
    return individual1,individual2
  if crossover_point == -1:#No crossover point set, generate a random one
    crossover_point = np.random.randint(1,len(individual1))

  if crossover_point > len(individual1) or crossover_point > len(individual2):
    print("Crossover point {} larger than genome sizes ({})".format(crossover_point,individual1,individual2))

  #Select the appropriate sections of the genome string and exchange them
  new_individual1 = individual1[:crossover_point] + individual2[crossover_point:]
  new_individual2 = individual2[:crossover_point] + individual1[crossover_point:]

  return new_individual1,new_individual2


import string
import random

def generate_random_char():
  """Returns a random character"""
  random_char = random.choice('123cnCNF(=OH')

  return random_char

def mutate(individual):

  gene_num = np.random.randint(0,55)

  #puts a randomly generated genome (character) at the position specified by gene_num
  individual = individual[:gene_num] + generate_random_char() + individual[gene_num+1:]
  return individual

print("Original:",(population[0]))
print("Mutant:",(mutate(population[0])))

selection_method = "proportionate" #valid values are "proportionate","rank" or "tournament"
selection_params = {}

population = np.array(["O=C(c1ccc(F)c(F)c1Nc1ccc(I)cc1F)N1CC(O)([C@@H]2CCCCN2)C1","COc1c(OCCCN2CCOCC2)ccc2c1N=C(NC(=O)c1cnc(N)nc1)N1CCN=C21",
         "CS(=O)(=O)c1ccc(C(=O)Nc2ccc(Cl)c(-c3ccccn3)c2)c(Cl)c1ccc","C[C@@H](Oc1cc(-c2cnn(C3CCNCC3)c2)cnc1N)c1c(Cl)ccc(F)c1Cl",
         "CCCCCCCCCC(C)C1OCc2c(C[N+](C)(C)CCCNC(=O)CCCCC)cnc(C)c2O","CCCCCCCCCC(C)C1OCc2c(C[N+](C)(C)CCCNC(=O)CCCCC)cnc(C)c2O",
         "FC(F)(F)c1cccc([C+](c2c[nH]c3ccccc23)c2c[nH]c3ccccc23)c1","C=CCc1cccc(Oc2ccc(C(=O)CC)cc2)c1OCCC[N+](C)(C)CC(=O)NCCC",
         "CCCCCCCCCCCCCCOc1cccc(CN(C(C)=O)c2cccc(C[n+]3csc(C)c3)c2","COc1ccc(CC(=O)NC(=N)N[C@H](CO)C(=O)Nc2cc(S(N)(=O)=O)ccc2",
         "N=C(N)c1ccc(C2=NOC(CC(=O)N[C@H](CC(=O)O)Cc3ccccc3)C2)cc1"])

def print_population_stats(population):
  """Prints the best fitness, mean fitness and diversity in the population"""

  fitnesses  = get_population_fitness(population)
  max_fitness = np.max(fitnesses)
  mean_fitness = np.mean(fitnesses)

  print("Population stats   Best fitness = {:4.2f}   Mean fitness = {:4.2f} ".format(max_fitness,mean_fitness))

print_population_stats(population)

 #How many generations the GA will be run for
generation_num = 5

selection_method = "proportionate" #valid values are "proportionate","rank" and "tournament"
selection_params = {}#parameters for the selection method

#These probabilities decide how often to apply the crossover and mutation operators to the selected population
#In this implimentation crossover and mutation occur sequentially
crossover_rate = 0.1 #The probability of performing crossover on a individual per generation
mutation_rate = 0.01 #The probability of performing mutation on an individual per generation

#Initialise the population



print("-----------Initial population-----------")
print(population)
print_population_stats(population)

#Begin the evolution loop
for g in range(generation_num):

  #Evaluate the individuals
  fitnesses = get_population_fitness(population)
  if np.isnan(fitnesses).any():#Breaks the loop if the fitness function isn't implimented
    print("ERROR - Fitness function not implimented!")
    break
  #Select the fitest individuals
  population = perform_selection(population,fitnesses,selection_method,selection_params)

  #Apply crossover operations
  for individual1_index in range(population.size):

    if np.random.random() < crossover_rate: #Crossover happens with a certain probability

      #Select an individual to do crossover with
      potential_individuals = list(range(population.size))
      potential_individuals.remove(individual1_index)     #can't do crossover with the same individual (nothing would change)
      individual2_index = np.random.choice(potential_individuals)

      #Apply one point crossover to produce new individuals
      new_individual1,new_individual2 = one_point_crossover(population[individual1_index],population[individual2_index])

      #Insert the new individuals back into the population
      population[individual1_index] = new_individual1
      population[individual2_index] = new_individual2


  #Apply mutation operations
  for individual_index in range(population.size):
    if np.random.random() < mutation_rate:#Decide to apply a mutation or not
      population[individual_index] = mutate(population[individual_index])


print("-----------End population-----------")
print(population)
print_population_stats(population)